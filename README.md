Данные рекомендации используются для написания кода проекта AMLCrypto и соотносятся с принципами кодирования PEP-8 на языке Python. Обратите внимание, что данный документ является лишь руководством, от которого в некоторых сценариях можно отходить.

# **Содержание**
1. [Ввнешний вид кода](#CodeView)
    * [Отступы](#Indents)
    * [Максимальная длина строки](#MaxRowLen)
    * [Пустые строки](#EmptyRows)
    * [Импорты](#Imports)
2. [Пробелы в выражениях и инструкциях](#Spaces)
3. [Комментарии](#Comments)
    * [Блочные комментарии](#BlockComments)
    * [Встрочные комментарии](#InlineComments)
    * [Строки документации](#Documentation)
4. [Соглашения по именованию](#Naming)
    * [Имена модулей и пакетов](#ModuleNames)
    * [Имена классов](#ClassNames)
    * [Имена функций и переменных](#FunctionNames)
    * [Аргументы функций и методов](#ArgumentNames)
    * [Имена методов и переменных экземляров классов](#MethodNames)
    * [Константы](#Constants)
5. [Структура класса](#ClassStructure)
6. [Проектирование наследования](#Inheritance)
    * [Главное](#Main)
    * [Рекомендации](#InheritanceRecomendations)
7. [Общие рекомендации](#CommonRecomendations)
    * [Сравнение](#Comparing)
    * [lambda функции](#Lambda)
    * [Исключения](#Exceptions)
    * [Менеджеры контекста](#ContextManagers)
    * [Последовательности и логические типы](#SequenceLogic)
    * [Подсказки типов](#TypeHints)
    

## **Внешний вид кода** <a id="CodeView"></a>

### **Отступы** <a id="Indents"></a>
В качестве отступов используем 4 пробела. Далее отступами определяются именно 4 пробела.

Продолжительные строки должны выравнивать обёрнутые элементы вертикально, используя неявную линию в скобках (круглых, квадратных или фигурных). Например:
```python
# Выравнивание по открывающему разделителю
result = some_function_name(argument1, argument2, 
                            argument3, argument4)
```

В качестве исключения, когда длина строки с открывающим элементом оказывается слишком длинной, можно использовать перенос следующим образом:
```python
# Выравнивание по открывающему разделителю
result = some_very_long_function_name(
    argument1, argument2, 
    argument3, argument4)
```
Обратите внимание, что в таком случае перед аргументами используется одиночный отступ. При написании условных выражений/циклов или определения функций используется два отступа:
```python
# В случае с длиным названием функции можно использовать 
# перенос аргументов с двойным отступом, чтобы отделить 
# ее тело
def some_very_long_function_name(
        argument1, argument2, 
        argument3, argument4):
    print(argument1)

# Аналогичное применение для других конструкций
if some_very_long_expression_with_a_lot_of_arguments(
        argument1, argument2, 
        argument3, argument4):
    print(argument1)

# В редких случаях допускается также следующее оформление
def some_very_long_function_name(
        argument1, argument2, 
        argument3, argument4
    ):
    print(argument1)
```

Закрывающие круглые/квадратные/фигурные скобки при написании многострочных выражений должны быть на том же уровне (иметь столько же отступов), что и начало выражения, например:
```python
account = {
    'address': 'some_address',
    'cash': 42
}

accounts_list = [
    {
        'address': 'some_address_1',
        'cash': 4815
    },
    {
        'address': 'some_address_2',
        'cash': 162342
    }
]
```

### **Максимальная длина строки** <a id="MaxRowLen"></a>
Рекомендуется ограничить длину строки 80-ю символами. Данное ограничение позволяет иметь несколько открытых бок о бок файлов и хорошо работает при использовании инструментов анализа кода, которые предоставляют две версии в соседних столбцах.

Предпочтительный способ переноса длинных строк является использование подразумеваемых продолжений строк Python внутри круглых, квадратных и фигурных скобок. Длинные строки могут быть разбиты на несколько строк, обернутые в скобки. Это предпочтительнее использования обратной косой черты для продолжения строки.

Обратная косая черта все еще может быть использована время от времени. Например, длинная конструкция with не может использовать неявные продолжения, так что обратная косая черта является приемлемой:
```python
with open('/path/to/some/file/you/want/to/read') as file_1, \
        open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

### **Пустые строки** <a id="EmptyRows"></a>
Отделяйте функции верхнего уровня и определения классов двумя пустыми строками.

Определения методов внутри класса разделяются одной пустой строкой.

Дополнительные пустые строки возможно использовать для разделения различных групп похожих функций. Пустые строки могут быть опущены между несколькими связанными однострочниками (например, набор фиктивных реализаций).

Используйте пустые строки в функциях, чтобы указать логические разделы.

### **Импорты** <a id="Imports"></a>
Каждый импорт должен быть на отдельной строке:
```python
# Правильно
import os
import sys

# Неправильно
import os, sys
```

При использовании импортирования при помощи **from** (импортирование отдельных функций/классов из модуля) допускается следующее:
```python
from skelarn.linear_models import LinearRegression, LogisticRegression
```

**Запрещается** использование шаблонов импорта:
```python
from some_module import *
```

Импорты всегда помещаются в начале файла, сразу после комментариев к модулю и строк документации, и перед объявлением констант.

Импорты должны быть сгруппированы в следующем порядке:
1. Импорты из стандартной библиотеки;
2. Импорты сторонних библиотек;
3. Импорты модулей текущего проекта.

Вставляйте пустую строку между каждой группой импортов.

Рекомендуется абсолютное импортирование, так как оно обычно более читаемо и ведет себя лучше (или, по крайней мере, даёт понятные сообщения об ошибках) если импортируемая система настроена неправильно (например, когда каталог внутри пакета заканчивается на sys.path):
```python
import package.utils
from package import utils
from package.utils import get_summary
```

## **Пробелы в выражениях и инструкциях** <a id="Spaces"></a>

Избегайте использования пробелов: 
* Непосредственно внутри круглых/квадратных/фигурных скобок:
    ```python
    # Правильно
    spam(ham[1], {eggs: 2})

    # Неправильно
    spam( ham[ 1 ], { eggs: 2 } )
    ```
* Непосредственно перед запятой, точкой с запятой или двоеточием:
    ```python
    # Правильно
    if x == 4: print(x, y); x, y = y, x

    # Неправильно
    if x == 4 : print(x , y) ; x , y = y , x
    ```
* Сразу перед открывающей скобкой, после которой начинается список аргументов при вызове функции:
    ```python
    # Правильно
    spam(1)

    # Неправильно
    spam (1)
    ```
* Для выравнивания оператора присваивания (или любого другого) с другими операторами:
    ```python
    # Правильно
    x = 1
    y = 2
    long_variable = 3

    # Неправильно
    x             = 1
    y             = 2
    long_variable = 3
    ```

Другие рекомендации:
* Всегда окружайте эти бинарные операторы одним пробелом с каждой стороны: присваивания (=, +=, -= и другие), сравнения (==, <, >, !=, <>, <=, >=, in, not in, is, is not), логические (and, or, not).
* Если используются операторы с разными приоритетами, попробуйте добавить пробелы вокруг операторов с самым низким приоритетом. Используйте свои собственные суждения, однако, никогда не используйте более одного пробела, и всегда используйте одинаковое количество пробелов по обе стороны бинарного оператора.
    ```python
    # Правильно
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)

    # Неправильно
    i=i+1
    submitted +=1
    x = x * 2 - 1
    hypot2 = x * x + y * y
    c = (a + b) * (a - b)
    ```
* Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по умолчанию.
    ```python
    # Правильно
    def complex(real, imag=0.0):
        return magic(r=real, i=imag)

    # Неправильно
    def complex(real, imag = 0.0):
        return magic(r = real, i = imag)
    ```
* Не используйте составные инструкции (несколько команд в одной строке).
    ```python
    # Правильно
    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()

    # Неправильно
    if foo == 'blah': do_blah_thing()
    do_one(); do_two(); do_three()
    ```
* Всегда пишите тело циклов/условных выражений/функций в отдельной строке, это позволяет повысить читаемость кода:
    ```python
    # Правильно:
    if person.saw_aliens: 
        MiB.use_neuralyzer(person)
    for item in suitcase:
        print(item)

    # Неправильно:
    if person.saw_aliens: MiB.use_neuralyzer(person)
    for item in suitcase: print(item)
    ```

## **Комментарии** <a id="Comments"></a>
Комментарии, противоречащие коду, хуже, чем отсутствие комментариев. Всегда исправляйте комментарии, если меняете код!

Комментарии должны являться законченными предложениями. Если комментарий — фраза или предложение, первое слово должно быть написано с большой буквы, если только это не имя переменной, которая начинается с маленькой буквы (никогда не изменяйте регистр переменной!).

Если комментарий короткий, можно опустить точку в конце предложения. Блок комментариев обычно состоит из одного или более абзацев, составленных из полноценных предложений, поэтому каждое предложение должно оканчиваться точкой.

Комментарий, за исключением редких случаев, должен пояснять, что делает тот или иной код, а не как он это делает (в противном случае комментарий дублирует написанный код). Например:
```python
# Правильно
def binsearch(sequence: list[int], start: int, 
              finish: int, elem: int) -> int:
    # The function performs a binary search for the element 
    # elem in the list within the positions [start, finish] 
    # and returns its index. If the element is not in the 
    # list, the index of the element closest to it is returned.
    if start >= finish:
        return start
    middle = (finish + start) // 2
    if sequence[middle] > elem:
        return binsearch(sequence, start, middle - 1, elem)
    elif sequence[middle] < elem:
        return binsearch(sequence, middle + 1, finish, elem)
    else:
        return middle

# Неправильно
def binsearch(sequence: list[int], start: int, 
              finish: int, elem: int) -> int:
    # Checks if start position greater than or equal to finish position.
    if start >= finish:
        return start
    # Finds middle position of the segment.
    middle = (finish + start) // 2
    if sequence[middle] > elem:  
        # If elem less than middle element of the list
        # then call binary search on the left subsegment.
        return binsearch(sequence, start, middle - 1, elem)
    elif sequence[middle] < elem:
        # If elem greater than middle element of the list
        # then call binary search on the right subsegment.
        return binsearch(sequence, middle + 1, finish, elem)
    else:
        # If middle element is equal to elem then return its index.
        return middle
```

Все комментарии и строки документации должны быть написаны на **английском языке**.

### **Блочные комментарии** <a id="BlockComments"></a>
Блок комментариев обычно объясняет код (весь, или только некоторую часть), идущий после блока, и должен иметь тот же отступ, что и сам код. Каждая строчка такого блока должна начинаться с символа # и одного пробела после него (если только сам текст комментария не имеет отступа).

Абзацы внутри блока комментариев разделяются строкой, состоящей из одного символа #.

### **Встрочные комментарии** <a id="InlineComments"></a>
Старайтесь реже использовать подобные комментарии.

Такой комментарий находится в той же строке, что и инструкция. "Встрочные" комментарии должны отделяться по крайней мере двумя пробелами от инструкции. Они должны начинаться с символа # и одного пробела.

Комментарии в строке с кодом не нужны и только отвлекают от чтения, если они объясняют очевидное. Не пишите вот так:
```python
x = x + 1   # Increment x
```
Впрочем, такие комментарии иногда полезны:
```python
x = x + 1   # Border compensation
```

### **Строки документации** <a id="Documentation"></a>
Пишите документацию для всех **публичных** модулей, функций, классов, методов. Строки документации необязательны для приватных методов, но лучше написать, что делает метод. Комментарий нужно писать после строки с def.

Документация оформляется следующим образом:

```python
import pandas as pd

def upload_transactions(addresses: list[str],
                        connector: Connector) -> pd.DataFrame:
        """
        Upload transactions data for given addresses. 

        Parameters
        ----------
        addresses: list[str]
            Addresses for data uploading.

        connector: Connector
            Connector instance that will request data for given addresses
            from blockchain.
        ----------

        Returns
        -------
        pandas.DataFrame instance with transactions data. 
        -------

        Examples
        --------
        Suppose we have some addresses and Connector instance. Let's
        upload data:
        >>> txs_data = upload_transactions(addresses, connector)
        --------
        """
        ...
```

Первым делом идёт описание того, что делает функция/метод. Далее список параметров с указанием типов и описанием, после чего возвращемые значения. Секция с примерами использования является опциональной. Рекомендуется оставлять примеры использования для классов и функций/методов с большим количеством параметров и сценариев использования в то время, как для простых функций данную секцию можно опустить.

Описание класса приводится в его методе **\_\_init\_\_**, например:
```python
from typing import Union
from datetime import datetime
from pandas import DataFrame

class DataLoader:
    def __init__(self, addresses: list[str],
                 from_date: datetime = None, 
                 to_date: datetime = None,
                 max_counterparties: int = None,
                 neighbour_distance: int = 0,
                 token_std: Union[str, list[str]] = 'erc20') -> DataFrame:
        """
        Description

        Parameters
        ----------
        ...
        ----------

        Examples
        --------
        ...
        --------
        """
        ...
```

## **Соглашения по именованию** <a id="Naming"></a>

При именовании переменных/функций/методов/классов стоит сперва обратиться к зарегистрированному пулу имён. Пул имён предлагается для стандартизации именования во всём проекте и использует устоявшиеся в области имена, по типу **connector**, **response**, **DataLoader**, **utils** и др.

### **Имена модулей и пакетов** <a id="ModuleNames"></a>
Модули должны иметь короткие имена, состоящие из маленьких букв. Можно использовать символы подчёркивания, если это улучшает читабельность. То же самое относится и к именам пакетов, однако в именах пакетов не рекомендуется использовать символ подчёркивания.

Так как имена модулей отображаются в имена файлов, а некоторые файловые системы являются нечувствительными к регистру символов и обрезают длинные имена, очень важно использовать достаточно короткие имена модулей — это не проблема в Unix, но, возможно, код окажется непереносимым в старые версии Windows, Mac, или DOS.

Когда модуль расширения, написанный на С или C++, имеет сопутствующий python-модуль (содержащий интерфейс высокого уровня), С/С++ модуль начинается с символа подчеркивания, например, _socket.

### **Имена классов** <a id="ClassNames"></a>
Имена классов должны следовать соглашению **CamelCase**. Например, **DataLoader**, **FeatureMaker**, **EtheriumConnector**.

### **Имена функций и переменных** <a id="FunctionNames"></a>
Имена функций и переменных должны состоять из маленьких букв, а слова разделяться символами подчеркивания — это необходимо, чтобы увеличить читабельность, т.е. для имён функций и переменных используем **snake_case**.

Имя функции/переменной должно отражать её назначение. В именах функций лучше использовать какие-нибудь глаголы, например **load**, **dump**, **get** и т.д.

### **Аргументы функций и методов** <a id="ArgumentNames"></a>
Всегда используйте self в качестве первого аргумента метода экземпляра объекта.

Всегда используйте cls в качестве первого аргумента метода класса.

Если имя аргумента конфликтует с зарезервированным ключевым словом python, обычно лучше добавить в конец имени символ подчеркивания, чем исказить написание слова или использовать аббревиатуру. Таким образом, *class_* лучше, чем *clss*. (Возможно, хорошим вариантом будет подобрать синоним).

### **Имена методов и переменных экземпляров классов** <a id="MethodNames"></a>
Используйте тот же стиль, что и для имен функций: имена должны состоять из маленьких букв, а слова разделяться символами подчеркивания.

Используйте один символ подчёркивания перед именем для непубличных методов и атрибутов, например:
```python
class Loader:
    def __init__(self, path: str, chunk: int):
        self._path = path  # Non-public field
        self._chunk = chunk  # Non-public field

    def __call__(self):
        return self._load()

    # Non-public method
    def _load(self):
        with open(self._path, 'r') as file:
            yield file.read(self._chunk)
```

Чтобы избежать конфликтов имен с подклассами, используйте два ведущих подчеркивания. Python искажает эти имена: если класс **Foo** имеет атрибут с именем **__a**, он не может быть доступен как **Foo.__a**. (Настойчивый пользователь все еще может получить доступ, вызвав **Foo._Foo__a.**) Вообще, два ведущих подчеркивания должны использоваться только для того, чтобы избежать конфликтов имен с атрибутами классов, предназначенных для наследования.

### **Константы** <a id="Constants"></a>
Константы должны объявляются на уровне модуля и записываются только заглавными буквами, а слова разделяются символами подчеркивания. Например: **MAX_OVERFLOW**, **TOTAL**.

## **Структура класса** <a id="ClassStructure"></a>
Проектируйте свои классы в соответствии со следующим порядком:
* Переменные уровня класса;
* **\_\_init\_\_** — конструктор;
* Свойства;
* Магические методы;
* "Виртуальные" методы;
* Публичные методы;
* Методы класса (*@classmethod*);
* Статические методы (*@staticmethod*);
* Непубличные методы.

Пример:
```python
class Animal:
    SOUND = None

    def make_sound(self):
        raise NotImplementedError


class Dog(Animal):
    SOUND = 'woof'

    def __init__(self, name, age):
        self.name = name
        self.age = age
        self.speed = 0
        self.moving = False

    @property
    def human_age(self):
        return self.age * 7

    @human_age.setter
    def human_age(self, value):
        self.age = value / 7

    def __str__(self):
        return '{} is {} years old'.format(
            self.name, self.age
        )

    def __eq__(self, other):
        return self.name == other.name and self.age == other.age

    def make_sound(self):
        print(self.SOUND)

    def bark(self):
        self.make_sound()

    def walk(self, speed, distance):
        self._set_speed(speed)
        self._move(distance)

    @classmethod
    def can_woof(cls, animal):
        return animal.SOUND == cls.SOUND

    @staticmethod
    def is_dog(animal):
        return animal.can_woof()

    def _set_speed(self, speed):
        self.speed = speed

    def _move(self, distance):
        self.moving = True
        for _ in range(distance):
            print('.', end='')
        print('')
```
Такая структура при чтении кода позволяет сперва изучить список констант, использующихся в классе, затем взглянуть на метод его создания и свойства, которыми будет обладать построенный объект. Далее происходит углубление в методы взаимодействия с созданным объектом других объектов (магические методы) и переопределённые методы, которые присущи базовому классу. Затем мы можем изучить, что этот класс поставляет помимо базового функционала (публичные методы, методы класса и статические методы). И в самом низу расположены методы, которые обеспечивают внутреннюю целостность взаимодействия с объектами класса — непубличные методы, которые не предполагают вызов извне.

## **Проектирование наследования** <a id="Inheritance"></a>
### **Главное** <a id="Main"></a>
Объекты, содержащиеся в каждой подобласти, должны иметь интерфейс или базовый класс, чтобы приложению не пришлось разделять логику между экземплярами одной и той же информационной единицы. Например, к каждому блокчейну необходим свой коннектор. Для того, чтобы стандартизировать их представления вводится интерфейс **BaseConnector**, включающий все необходимые поля и методы, которые должны быть реализованы в любом другом коннекторе. Тогда приложение будет способно вызывать методы, заложенные в интерфейсе **BaseConnector**, без заботы об их существовании.

Обязательно решите, каким должен быть метод класса или экземпляра класса (далее - атрибут) — публичный или непубличный. Если вы сомневаетесь, выберите непубличный атрибут. Потом будет проще сделать его публичным, чем наоборот.

Публичные атрибуты — это те, которые будут использовать другие программисты, и вы должны быть уверены в отсутствии обратной несовместимости. Непубличные атрибуты, в свою очередь, не предназначены для использования третьими лицами, поэтому вы можете не гарантировать, что не измените или не удалите их.

Другой тип атрибутов классов принадлежит так называемому API подклассов (в других языках они часто называются protected). Некоторые классы проектируются так, чтобы от них наследовали другие классы, которые расширяют или модифицируют поведение базового класса. Когда вы проектируете такой класс, решите и явно укажите, какие атрибуты являются публичными, какие принадлежат API подклассов, а какие используются только базовым классом.

### **Рекомендации** <a id="InheritanceRecomendations"></a>
* Открытые атрибуты не должны иметь в начале имени символа подчеркивания.
* Если имя открытого атрибута конфликтует с ключевым словом языка, добавьте в конец имени один символ подчеркивания. Это более предпочтительно, чем аббревиатура или искажение написания (однако, у этого правила есть исключение — аргумент, который означает класс, и особенно первый аргумент метода класса (class method) должен иметь имя cls).
* Назовите простые публичные атрибуты понятными именами и не пишите сложные методы доступа и изменения (**accessor**/**mutator**, **get**/**set**) Помните, что в python очень легко добавить их потом, если потребуется. В этом случае используйте свойства (properties), чтобы скрыть функциональную реализацию за синтаксисом доступа к атрибутам.
    * Примечание 1: Постарайтесь избавиться от побочных эффектов, связанным с функциональным поведением; впрочем, такие вещи, как кэширование, вполне допустимы.
    * Примечание 2: Избегайте использования вычислительно затратных операций, потому что из-за записи с помощью атрибутов создается впечатление, что доступ происходит (относительно) быстро.
* Если вы планируете класс таким образом, чтобы от него наследовались другие классы, но не хотите, чтобы подклассы унаследовали некоторые атрибуты, добавьте в имена два символа подчеркивания в начало, и ни одного — в конец. Механизм изменения имен в python сработает так, что имя класса добавится к имени такого атрибута, что позволит избежать конфликта имен с атрибутами подклассов.
    * Примечание 1: Будьте внимательны: если наследник будет иметь то же имя класса и имя атрибута, то вновь возникнет конфликт имен.
    * Примечание 2: Механизм изменения имен может затруднить отладку или работу с **\_\_getattr\_\_()**, однако он хорошо документирован и легко реализуется вручную.
    * Примечание 3: Не всем нравится этот механизм, поэтому старайтесь достичь компромисса между необходимостью избежать конфликта имен и возможностью доступа к этим атрибутам.

## **Общие рекомендации** <a id="CommonRecomendations"></a>
Код должен быть написан так, чтобы не зависеть от разных реализаций языка (PyPy, Jython, IronPython, Pyrex, Psyco и пр.).

Например, не полагайтесь на эффективную реализацию в CPython конкатенации строк в выражениях типа **a += b** или **a = a + b**. Такие инструкции выполняются значительно медленнее в Jython. В критичных к времени выполнения частях программы используйте **''.join()** — таким образом склеивание строк будет выполнено за линейное время независимо от реализации python.

### **Сравнение** <a id="Comparing"></a>
Сравнения с **None** должны обязательно выполняться с использованием операторов **is** или **is not**, а не с помощью операторов сравнения. Кроме того, не пишите **if x**, если имеете в виду **if x is not None** — если, к примеру, при тестировании такая переменная может принять значение другого типа, отличного от None, то при приведении типов условие окажется ложным и код не выполниться.

При реализации методов сравнения, лучше всего реализовать все 6 операций сравнения (**\_\_eq\_\_**, **\_\_ne\_\_**, **\_\_lt\_\_**, **\_\_le\_\_**, \_\_gt\_\_, *\_\_ge\_\_*), чем полагаться на то, что другие программисты будут использовать только конкретный вид сравнения.

Для минимизации усилий можно воспользоваться декоратором **functools.total_ordering()** для реализации недостающих методов.

Сравнение типов объектов нужно делать с помощью **isinstance()**, а не прямым сравнением типов:
```python
# Правильно
if isinstance(obj, int):

# Неправильно
if type(obj) is type(1):
```

### **lambda функции** <a id="Lambda"></a>
Всегда используйте выражение **def**, а не присваивание лямбда-выражения к имени, за исключением некоторых ситуаций, например:
```python
# В зависимости от режима recorder записывает данные либо 
# в базу данных, либо в список.
if mode == LOAD:
    db_module = DataBaseModule(connection_params)
    db_module.create_tables(TABLES)
    recorder = lambda tbl_name, table: db_module.write(tbl_name, table)
else:
    txs_data, balances_data = [], []
    recorder = lambda tbl_name, table: (txs_data.append(table) 
                                        if tbl_name == 'transactions' 
                                        else balances_data.append(table))
# Благодаря такому присваиванию далее можно не заботиться о значении
# переменной mode, ветвить и дублировать код, достаточно просто
# взаимодейтсовать с recorder'ом.
for tbl_name, tbl_data in load():
    recorder(tbl_name, tbl_data)
```

### **Исключения** <a id="Exceptions"></a>
Наследуйте свой класс исключения от **Exception**, а не от **BaseException**. Прямое наследование от BaseException зарезервировано для исключений, которые не следует перехватывать.

Когда код перехватывает исключения, перехватывайте конкретные ошибки вместо простого выражения "**except:**", например:
```python
try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None
```
Простое написание "**except:**" также перехватит и **SystemExit**, и **KeyboardInterrupt**, что породит проблемы, например, сложнее будет завершить программу нажатием **Ctrl+C**. Если вы действительно собираетесь перехватить все исключения, пишите "**except Exception:**".

При перехвате ошибок операционной системы, предпочитайте использовать явную иерархию исключений, введенную в Python 3.3, вместо анализа значений errno.

Старайтесь заключать в каждую конструкцию **try...except** минимум кода, чтобы легче отлавливать ошибки. Опять же, это позволяет избежать замаскированных ошибок.
```python
# Правильно
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)

# Неправильно
try:
    # Здесь много действий!
    return handle_value(collection[key])
except KeyError:
    # Здесь также перехватится KeyError, который может быть сгенерирован handle_value()
    return key_not_found(key)
```

### **Менеджеры контекста** <a id="ContextManagers"></a>
Когда ресурс является локальным на участке кода, используйте выражение **with** для того, чтобы после выполнения он был очищен оперативно и надёжно.

Менеджеры контекста следует вызывать с помощью отдельной функции или метода, всякий раз, когда они делают что-то другое, чем получение и освобождение ресурсов. Например:
```python
#Правильно
with conn.begin_transaction():
    do_stuff_in_transaction(conn)

#Неправильно
with conn:
    do_stuff_in_transaction(conn)
```
Последний пример не дает никакой информации, указывающей на то, что **\_\_enter\_\_** и **\_\_exit\_\_** делают что-то кроме закрытия соединения после транзакции. Быть явным важно в данном случае.

### **Последовательности и логические типы** <a id="SequenceLogic"></a>
Пользуйтесь **''.startswith()** и **''.endswith()** вместо обработки срезов строк для проверки суффиксов или префиксов. **startswith()** и **endswith()** выглядят чище и порождают меньше ошибок. Например:
```python
# Правильно
if foo.startswith('bar'):

# Неправильно
if foo[:3] == 'bar':
```

Для последовательностей (строк, списков, кортежей) используйте тот факт, что пустая последовательность есть false:
```python
# Правильно
if not seq: 
    pass
if seq: 
    pass

# Неправильно
if len(seq):
    pass
if not len(seq):
    pass
```

Не сравнивайте логические типы с True и False с помощью ==:
```python
# Правильно
if greeting:
    pass

# Неправильно
if greeting == True:
    pass
if greeting is True:
    pass
```

### **Подсказки типов** <a id="TypeHints"></a>
Всегда используйте подсказки типов для аргументов функций и методов, а также для возвращаемых значений. Например:
```python
class Person(object):
    def __init__(self, params: dict):
        self._params = params.copy()

    def erase_memory(self) -> bool:
        return self._params['memory'].clear()

class MiB(Organization):
    def __init__(self, employees_count: int):
        self._employees_count = employees_count

    def use_neuralyzer(self, person: Person) -> bool:
        return person.erase_memory()

def load_data(path: str, chunk: int) -> dict:
    ...
```

Если в качестве принимаемого/возвращаемого типа необходимо указать сам класс, то в самом начале файла из модуля **\_\_future\_\_** необходемо импортировать **annotations**, например:
```python
from __future__ import annotations

class Model:
    def __init__(self, *args, **kwargs):
        ...

    def eval(self) -> Model:
        ...

    def train(self) -> Model:
        ...
```
